(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@xuans-mini-react/react'), require('scheduler')) :
  typeof define === 'function' && define.amd ? define(['@xuans-mini-react/react', 'scheduler'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global["@xuans-mini-react/react-noop-renderer"] = factory(global.React, global.Scheduler));
})(this, (function (React, Scheduler) { 'use strict';

  function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n.default = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
  var Scheduler__namespace = /*#__PURE__*/_interopNamespaceDefault(Scheduler);

  const FunctionComponent = 0;
  // HostRoot is the root of a host tree. Could be nested inside another node.
  const HostRoot = 3;
  // A host component (eg a DOM element)
  const HostComponent = 5;
  const HostText = 6;
  const Fragment = 7;

  const NoFlags = 0;
  const Placement = 1;
  const Update = 1 << 1;
  const ChildDeletion = 1 << 2;
  const PassiveEffect = 1 << 3;
  const MutationMask = Placement | Update | ChildDeletion;
  const PassiveMask = PassiveEffect | ChildDeletion;

  const NoLane = 0b0000;
  const SyncLane = 0b0001;
  const NoLanes = 0b0000;
  function mergeLanes(a, b) {
      return a | b;
  }
  function requestUpdateLane() {
      return SyncLane;
  }
  function getHighestPriorityLane(lanes) {
      return lanes & -lanes;
  }
  function markRootFinished(root, lane) {
      root.pendingLanes &= ~lane;
  }

  class FiberNode {
      type;
      tag;
      pendingProps;
      key;
      stateNode;
      ref;
      return;
      sibling;
      child;
      index;
      memoizedProps;
      memoizedState;
      alternate;
      flags;
      subtreeFlags;
      updateQueue;
      deletions;
      constructor(tag, pendingProps, key) {
          // tag is the type of the fiber node
          this.tag = tag;
          this.key = key || null;
          // stateNode is the instance of the component
          this.stateNode = null;
          // type is the function component or host component
          this.type = null;
          // these form a tree structure
          // return is the pointer to the parent node
          this.return = null;
          this.sibling = null;
          this.child = null;
          this.index = 0;
          this.ref = null;
          // work unit
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.updateQueue = null;
          this.memoizedState = null;
          // alternate points to another fiber node
          this.alternate = null;
          // side effect flags
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.deletions = null;
      }
  }
  class FiberRootNode {
      container;
      current;
      finishedWork;
      pendingLanes;
      finishedLane;
      pendingPassiveEffects;
      constructor(container, hostRootFiber) {
          this.container = container;
          this.current = hostRootFiber;
          hostRootFiber.stateNode = this;
          this.finishedWork = null;
          this.pendingLanes = NoLanes;
          this.finishedLane = NoLane;
          this.pendingPassiveEffects = {
              unmount: [],
              update: [],
          };
      }
  }
  function createWorkInProgress(current, pendingProps) {
      let workInProgress = current.alternate;
      if (workInProgress === null) {
          workInProgress = new FiberNode(current.tag, pendingProps, current.key);
          workInProgress.stateNode = current.stateNode;
          workInProgress.alternate = current;
          current.alternate = workInProgress;
      }
      else {
          workInProgress.pendingProps = pendingProps;
          workInProgress.flags = NoFlags;
          workInProgress.subtreeFlags = NoFlags;
          workInProgress.deletions = null;
      }
      workInProgress.type = current.type;
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      return workInProgress;
  }
  function createFiberFromElement(element) {
      const { type, key, props } = element;
      let fiberTag = FunctionComponent;
      if (typeof type === 'string') {
          fiberTag = HostComponent;
      }
      else if (typeof type !== 'function') {
          {
              console.warn('Unknown fiber tag', type);
          }
      }
      const fiber = new FiberNode(fiberTag, props, key);
      fiber.type = type;
      return fiber;
  }
  function createFiberFromFragment(element, key) {
      const fiber = new FiberNode(Fragment, element, key);
      return fiber;
  }

  const createUpdate = (action, lane) => {
      return {
          action,
          lane,
      };
  };
  const createUpdateQueue = () => {
      return {
          shared: {
              pending: null,
          },
          dispatch: null,
      };
  };
  const enqueueUpdate = (updateQueue, update) => {
      const pending = updateQueue.shared.pending;
      if (pending === null) {
          update.next = update;
      }
      else {
          update.next = pending.next;
          pending.next = update;
      }
      updateQueue.shared.pending = update;
  };
  const processUpdateQueue = (baseState, pendingUpdate, renderLane) => {
      const result = {
          memoizedState: baseState,
      };
      if (pendingUpdate !== null) {
          const first = pendingUpdate.next;
          let pending = pendingUpdate.next;
          do {
              const updateLane = pending.lane;
              if (updateLane === renderLane) {
                  const action = pending.action;
                  if (action instanceof Function) {
                      baseState = action(baseState);
                  }
                  else {
                      baseState = action;
                  }
              }
              else {
                  {
                      console.error('Not implemented yet');
                  }
              }
              pending = pending.next;
          } while (pending !== first);
          result.memoizedState = baseState;
      }
      return result;
  };

  let instanceCounter = 0;
  const createInstance = (type, props) => {
      const instance = {
          id: instanceCounter++,
          type,
          children: [],
          parent: -1,
          props,
      };
      return instance;
  };
  const appendInitialChild = (parent, child) => {
      const prevParentId = child.parent;
      const parentId = 'rootId' in parent ? parent.rootId : parent.id;
      if (prevParentId !== -1 && prevParentId !== parentId) {
          throw new Error('Child already has a different parent');
      }
      child.parent = parentId;
      parent.children.push(child);
  };
  const createTextInstance = (text) => {
      const instance = {
          text,
          id: instanceCounter++,
          parent: -1,
      };
      return instance;
  };
  const appendChildToContainer = (parent, child) => {
      const prevParentId = child.parent;
      const parentId = parent.rootId;
      if (prevParentId !== -1 && prevParentId !== parentId) {
          throw new Error('Child already has a different parent');
      }
      child.parent = parentId;
      parent.children.push(child);
  };
  function commitTextUpdate(textInstance, content) {
      textInstance.text = content;
  }
  function removeChild(child, container) {
      const index = container.children.indexOf(child);
      if (index < 0) {
          throw new Error('Child not found');
      }
      container.children.splice(index, 1);
  }
  function commitPropsUpdate(instance, props) {
      instance.props = props || {};
  }
  function insertChildToContainer(child, container, before) {
      const beforeIndex = container.children.indexOf(before);
      if (beforeIndex < 0) {
          throw new Error('Before node not found');
      }
      const index = container.children.indexOf(child);
      if (index >= 0) {
          container.children.splice(index, 1);
      }
      container.children.splice(beforeIndex, 0, child);
  }
  const scheduleMicrotask = typeof queueMicrotask === 'function'
      ? queueMicrotask
      : typeof Promise === 'function'
          ? (callback) => Promise.resolve().then(callback)
          : setTimeout;

  const supportSymbol = typeof Symbol === 'function' && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for('react.element')
      : 0xeac7;
  const REACT_FRAGMENT_TYPE = supportSymbol
      ? Symbol.for('react.fragment')
      : 0xeacb;

  function ChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
              return;
          }
          const deletions = returnFiber.deletions;
          if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
          }
          else {
              deletions.push(childToDelete);
          }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) {
              return;
          }
          let childToDelete = currentFirstChild;
          while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
          }
      }
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          const key = element.key;
          while (currentFiber !== null) {
              if (currentFiber.key === key) {
                  if (element.$$typeof === REACT_ELEMENT_TYPE) {
                      if (element.type === currentFiber.type) {
                          let props = element.props;
                          if (element.type === REACT_FRAGMENT_TYPE) {
                              props = element.props.children;
                          }
                          // can reuse the existing fiber
                          const existing = useFiber(currentFiber, props);
                          existing.return = returnFiber;
                          // delete the siblings
                          deleteRemainingChildren(returnFiber, currentFiber.sibling);
                          return existing;
                      }
                      // same key but different type, impossible to reuse
                      deleteRemainingChildren(returnFiber, currentFiber);
                      break;
                  }
                  else {
                      {
                          console.warn('Unknown child type', element);
                          break;
                      }
                  }
              }
              else {
                  // delete the old child
                  deleteChild(returnFiber, currentFiber);
                  currentFiber = currentFiber.sibling;
              }
          }
          let fiber;
          if (element.type === REACT_FRAGMENT_TYPE) {
              fiber = createFiberFromFragment(element.props.children, key);
          }
          else {
              fiber = createFiberFromElement(element);
          }
          fiber.return = returnFiber;
          return fiber;
      }
      function reconcileSingleTextNode(returnFiber, currentFiber, content) {
          while (currentFiber !== null) {
              if (currentFiber.tag === HostText) {
                  const existing = useFiber(currentFiber, { content });
                  existing.return = returnFiber;
                  deleteRemainingChildren(returnFiber, currentFiber.sibling);
                  return existing;
              }
              deleteChild(returnFiber, currentFiber);
              currentFiber = currentFiber.sibling;
          }
          const fiber = new FiberNode(HostText, { content }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      function placeSingleChild(newFiber) {
          if (shouldTrackSideEffects && newFiber.alternate === null) {
              newFiber.flags = newFiber.flags | Placement;
          }
          return newFiber;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChild) {
          // last reusable fiber's index in current
          let lastPlacedIndex = 0;
          let lastNewFiber = null;
          let firstNewFiber = null;
          // save current to map
          const existingChildren = new Map();
          let current = currentFirstChild;
          while (current !== null) {
              const keyToUse = current.key !== null ? current.key : current.index;
              existingChildren.set(keyToUse, current);
              current = current.sibling;
          }
          // iterate newChild to see if we can reuse the existing fiber
          for (let i = 0; i < newChild.length; i++) {
              const after = newChild[i];
              const newFiber = updateFromMap(returnFiber, existingChildren, i, after);
              if (newFiber === null) {
                  continue;
              }
              // insertions or moves
              newFiber.index = i;
              newFiber.return = returnFiber;
              if (lastNewFiber === null) {
                  firstNewFiber = newFiber;
                  lastNewFiber = newFiber;
              }
              else {
                  lastNewFiber.sibling = newFiber;
                  lastNewFiber = lastNewFiber.sibling;
              }
              if (!shouldTrackSideEffects) {
                  continue;
              }
              const current = newFiber.alternate;
              if (current !== null) {
                  const oldIndex = current.index;
                  if (oldIndex < lastPlacedIndex) {
                      // move
                      newFiber.flags = newFiber.flags | Placement;
                      continue;
                  }
                  else {
                      // no move
                      lastPlacedIndex = oldIndex;
                  }
              }
              else {
                  // mount
                  newFiber.flags = newFiber.flags | Placement;
              }
          }
          // mark leftover children as deletions
          existingChildren.forEach((child) => deleteChild(returnFiber, child));
          return firstNewFiber;
      }
      function updateFromMap(returnFiber, existingChildren, index, element) {
          const keyToUse = element?.key != null ? element.key : index;
          const before = existingChildren.get(keyToUse) || null;
          // HostText
          if (typeof element === 'string' || typeof element === 'number') {
              if (before) {
                  if (before.tag === HostText) {
                      existingChildren.delete(keyToUse);
                      return useFiber(before, { content: element + '' });
                  }
              }
              return new FiberNode(HostText, { content: element + '' }, null);
          }
          if (typeof element === 'object' && element !== null) {
              if (Array.isArray(element)) {
                  return updateFragment(returnFiber, before, element, keyToUse, existingChildren);
              }
              else {
                  switch (element.$$typeof) {
                      case REACT_ELEMENT_TYPE:
                          if (element.type === REACT_FRAGMENT_TYPE) {
                              return updateFragment(returnFiber, before, element.props.children, keyToUse, existingChildren);
                          }
                          if (before) {
                              if (before.type === element.type) {
                                  existingChildren.delete(keyToUse);
                                  return useFiber(before, element.props);
                              }
                          }
                          return createFiberFromElement(element);
                  }
              }
          }
          return null;
      }
      return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
          const isUnkeyedTopLevelFragment = typeof newChild === 'object' &&
              newChild !== null &&
              newChild.$$typeof === REACT_FRAGMENT_TYPE &&
              newChild.key === null;
          if (isUnkeyedTopLevelFragment) {
              newChild = newChild?.props.children;
          }
          if (typeof newChild === 'object' && newChild !== null) {
              if (Array.isArray(newChild)) {
                  // TODO: multiple children
                  return reconcileChildrenArray(returnFiber, currentFiber, newChild);
              }
              else {
                  switch (newChild.$$typeof) {
                      case REACT_ELEMENT_TYPE:
                          return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                      default:
                          {
                              console.warn('Unknown child type', newChild);
                          }
                          break;
                  }
              }
          }
          // HostText
          if (typeof newChild === 'string' || typeof newChild === 'number') {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          currentFiber && deleteRemainingChildren(returnFiber, currentFiber);
          {
              console.warn('Unknown child type', newChild);
          }
          return null;
      };
  }
  function useFiber(fiber, pendingProps) {
      const clone = createWorkInProgress(fiber, pendingProps);
      clone.index = 0;
      clone.sibling = null;
      return clone;
  }
  function updateFragment(returnFiber, current, element, key, existingChildren) {
      let fiber;
      if (!current || current.tag !== Fragment) {
          fiber = createFiberFromFragment(element, key);
      }
      else {
          existingChildren.delete(key);
          fiber = useFiber(current, element);
      }
      fiber.return = returnFiber;
      return fiber;
  }
  const reconcileChildFibers = ChildReconciler(true);
  const mountChildFibers = ChildReconciler(false);

  const internals = React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  const Passive = 0b0010;
  const HookHasEffect = 0b0001;

  let currentlyRenderingFiber = null;
  let workInProgressHook = null;
  let currentHook = null;
  let renderLane = NoLane;
  const { currentDispatcher } = internals;
  function renderWithHooks(wip, lane) {
      currentlyRenderingFiber = wip;
      wip.memoizedState = null;
      wip.updateQueue = null;
      renderLane = lane;
      const current = wip.alternate;
      if (current !== null) {
          currentDispatcher.current = HooksDispatcherOnUpdate;
      }
      else {
          currentDispatcher.current = HooksDispatcherOnMount;
      }
      const Component = wip.type;
      const props = wip.pendingProps;
      const children = Component(props);
      currentlyRenderingFiber = null;
      workInProgressHook = null;
      currentHook = null;
      renderLane = NoLane;
      return children;
  }
  const HooksDispatcherOnMount = {
      useState: mountState,
      useEffect: mountEffect,
  };
  const HooksDispatcherOnUpdate = {
      useState: updateState,
      useEffect: updateEffect,
  };
  function mountEffect(create, deps) {
      const hook = mountWorkInProgressHook();
      const nextDeps = deps === undefined ? null : deps;
      currentlyRenderingFiber.flags |= PassiveEffect;
      hook.memoizedState = pushEffect(Passive | HookHasEffect, create, undefined, nextDeps);
  }
  function updateEffect(create, deps) {
      const hook = updateWorkInProgressHook();
      const nextDeps = deps === undefined ? null : deps;
      let destroy;
      if (currentHook !== null) {
          const prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;
          if (nextDeps !== null) {
              const prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(Passive, create, destroy, nextDeps);
                  return;
              }
          }
          currentlyRenderingFiber.flags |= PassiveEffect;
          hook.memoizedState = pushEffect(Passive | HookHasEffect, create, destroy, nextDeps);
      }
  }
  function areHookInputsEqual(nextDeps, prevDeps) {
      if (prevDeps === null || nextDeps === null) {
          return false;
      }
      if (nextDeps.length !== prevDeps.length) {
          return false;
      }
      for (let i = 0; i < prevDeps.length; i++) {
          if (nextDeps[i] !== prevDeps[i]) {
              return false;
          }
      }
      return true;
  }
  function pushEffect(hookFlags, create, destroy, deps) {
      const effect = {
          tag: hookFlags,
          create,
          destroy,
          deps,
          next: null,
      };
      const fiber = currentlyRenderingFiber;
      if (fiber === null) {
          throw new Error('Unexpected render phase');
      }
      const updateQueue = fiber.updateQueue;
      if (updateQueue === null) {
          const updateQueue = createFCUpdateQueue();
          fiber.updateQueue = updateQueue;
          effect.next = effect;
          updateQueue.lastEffect = effect;
      }
      else {
          const lastEffect = updateQueue.lastEffect;
          if (lastEffect === null) {
              effect.next = effect;
              updateQueue.lastEffect = effect;
          }
          else {
              effect.next = lastEffect.next;
              lastEffect.next = effect;
              updateQueue.lastEffect = effect;
          }
      }
      return effect;
  }
  function createFCUpdateQueue() {
      const updateQueue = createUpdateQueue();
      updateQueue.lastEffect = null;
      return updateQueue;
  }
  function updateState() {
      const hook = updateWorkInProgressHook();
      const queue = hook.updateQueue;
      const pending = queue.shared.pending;
      queue.shared.pending = null;
      if (pending !== null) {
          const { memoizedState } = processUpdateQueue(hook.memoizedState, pending, renderLane);
          hook.memoizedState = memoizedState;
      }
      return [hook.memoizedState, queue.dispatch];
  }
  function updateWorkInProgressHook() {
      // TODO: handle update triggerd in render
      let nextCurrentHook = null;
      if (currentHook === null) {
          const current = currentlyRenderingFiber?.alternate;
          nextCurrentHook = current?.memoizedState;
      }
      else {
          nextCurrentHook = currentHook.next;
      }
      if (nextCurrentHook === null) {
          throw new Error('Rendered more hooks than during the previous render.');
      }
      currentHook = nextCurrentHook;
      const newHook = {
          memoizedState: currentHook.memoizedState,
          updateQueue: currentHook.updateQueue,
          next: null,
      };
      if (workInProgressHook === null) {
          if (currentlyRenderingFiber === null) {
              throw new Error('Hooks can only be called inside the body of a function component.');
          }
          else {
              workInProgressHook = currentlyRenderingFiber.memoizedState = newHook;
          }
      }
      else {
          workInProgressHook = workInProgressHook.next = newHook;
      }
      return workInProgressHook;
  }
  function mountState(initialState) {
      const hook = mountWorkInProgressHook();
      if (initialState instanceof Function) {
          hook.memoizedState = initialState();
      }
      else {
          hook.memoizedState = initialState;
      }
      const queue = createUpdateQueue();
      hook.updateQueue = queue;
      const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, 
      // @ts-expect-error let me do it
      queue);
      queue.dispatch = dispatch;
      return [hook.memoizedState, dispatch];
  }
  function dispatchSetState(fiber, updateQueue, action) {
      const lane = requestUpdateLane();
      const update = createUpdate(action, lane);
      enqueueUpdate(updateQueue, update);
      scheduleUpdateOnFiber(fiber, lane);
  }
  function mountWorkInProgressHook() {
      const hook = {
          memoizedState: null,
          updateQueue: null,
          next: null,
      };
      if (workInProgressHook === null) {
          if (currentlyRenderingFiber === null) {
              throw new Error('Hooks can only be called inside the body of a function component.');
          }
          currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
      }
      else {
          workInProgressHook = workInProgressHook.next = hook;
      }
      return workInProgressHook;
  }

  const beginWork = (wip, renderLane) => {
      // return child fiber
      switch (wip.tag) {
          case HostRoot:
              return updateHostRoot(wip, renderLane);
          case HostComponent:
              return updateHostComponent(wip);
          case HostText:
              return null;
          case FunctionComponent:
              return updateFunctionComponent(wip, renderLane);
          case Fragment:
              return updateFragmentComponent(wip);
          default:
              {
                  console.warn('Unknown fiber tag', wip.tag);
              }
              return null;
      }
  };
  function updateFragmentComponent(wip) {
      const nextChildren = wip.pendingProps;
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateFunctionComponent(wip, renderLane) {
      const nextChildren = renderWithHooks(wip, renderLane);
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateHostRoot(wip, renderLane) {
      const baseState = wip.memoizedState;
      const updateQueue = wip.updateQueue;
      const pending = updateQueue.shared.pending;
      updateQueue.shared.pending = null;
      const { memoizedState } = processUpdateQueue(baseState, pending, renderLane);
      wip.memoizedState = memoizedState;
      const nextChildren = wip.memoizedState;
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateHostComponent(wip) {
      const nextProps = wip.pendingProps;
      const nextChildren = nextProps.children;
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function reconcileChildren(wip, children) {
      const current = wip.alternate;
      if (current !== null) {
          // update
          wip.child = reconcileChildFibers(wip, current.child, children);
      }
      else {
          // mount
          wip.child = mountChildFibers(wip, null, children);
      }
  }

  let nextEffect = null;
  const commitMutationEffects = (finishedWork, root) => {
      nextEffect = finishedWork;
      while (nextEffect !== null) {
          const child = nextEffect.child;
          if ((nextEffect.subtreeFlags & (MutationMask | PassiveMask)) !== NoFlags &&
              child) {
              nextEffect = child;
          }
          else {
              up: while (nextEffect !== null) {
                  commitMutationEffectsOnFiber(nextEffect, root);
                  const sibling = nextEffect.sibling;
                  if (sibling !== null) {
                      nextEffect = sibling;
                      break up;
                  }
                  nextEffect = nextEffect.return;
              }
          }
      }
  };
  function commitMutationEffectsOnFiber(finishedWork, root) {
      const flags = finishedWork.flags;
      if ((flags & Placement) !== NoFlags) {
          {
              console.warn('Placement');
          }
          commitPlacement(finishedWork);
          finishedWork.flags &= ~Placement;
      }
      if ((flags & Update) !== NoFlags) {
          {
              console.warn('Update');
          }
          commitUpdate(finishedWork);
          finishedWork.flags &= ~Update;
      }
      if ((flags & ChildDeletion) !== NoFlags) {
          {
              console.warn('ChildDeletion');
          }
          const deletions = finishedWork.deletions;
          if (deletions) {
              deletions.forEach((deletion) => commitDeletion(deletion, root));
          }
          finishedWork.flags &= ~ChildDeletion;
      }
      if ((flags & PassiveEffect) !== NoFlags) {
          commitPassiveEffect(finishedWork, root, 'update');
          finishedWork.flags &= ~PassiveEffect;
      }
  }
  function commitPassiveEffect(fiber, root, type) {
      if (fiber.tag !== FunctionComponent ||
          (type === 'update' && (fiber.flags & PassiveEffect) === NoFlags)) {
          return;
      }
      const updateQueue = fiber.updateQueue;
      if (updateQueue !== null) {
          if (updateQueue.lastEffect === null) {
              {
                  console.error('Passive effect without pending effect');
              }
              return;
          }
          root.pendingPassiveEffects[type].push(updateQueue.lastEffect);
      }
  }
  function commitHookEffectList(flags, lastEffect, callback) {
      let effect = lastEffect.next;
      do {
          if ((effect.tag & flags) === flags) {
              callback(effect);
          }
          effect = effect.next;
      } while (effect !== lastEffect.next);
  }
  function commitHookEffectListUnmount(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const destroy = effect.destroy;
          if (typeof destroy === 'function') {
              destroy();
          }
          effect.tag &= ~HookHasEffect;
      });
  }
  function commitHookEffectListDestroy(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const destroy = effect.destroy;
          if (typeof destroy === 'function') {
              destroy();
          }
      });
  }
  function commitHookEffectListCreate(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const create = effect.create;
          if (typeof create === 'function') {
              const destroy = create();
              effect.destroy = destroy;
          }
      });
  }
  function recordHostChildrenToDelete(childrenToDelete, unmountFiber) {
      const lastOne = childrenToDelete[childrenToDelete.length - 1];
      if (!lastOne) {
          childrenToDelete.push(unmountFiber);
      }
      else {
          let node = lastOne.sibling;
          while (node) {
              if (unmountFiber === node) {
                  childrenToDelete.push(unmountFiber);
              }
              else {
                  let parent = unmountFiber.return;
                  while (parent?.tag === Fragment) {
                      if (parent === node) {
                          childrenToDelete.push(unmountFiber);
                          return;
                      }
                      parent = parent.return;
                  }
              }
              node = node.sibling;
          }
      }
  }
  function commitDeletion(childToDelete, root) {
      const rootChildrenToDelete = [];
      commitNestedComponent(childToDelete, (unmountFiber) => {
          switch (unmountFiber.tag) {
              case HostComponent:
                  recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
                  // unbind refs
                  return;
              case HostText:
                  recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
                  return;
              case FunctionComponent:
                  // unmount effects
                  commitPassiveEffect(unmountFiber, root, 'unmount');
                  return;
              case Fragment:
                  return;
              default:
                  {
                      console.warn('Unhandled unmount');
                  }
          }
      });
      if (rootChildrenToDelete.length) {
          const hostParent = getHostParent(childToDelete);
          if (hostParent) {
              rootChildrenToDelete.forEach((child) => {
                  removeChild(child.stateNode, hostParent);
              });
          }
      }
      childToDelete.return = null;
      childToDelete.child = null;
  }
  function commitNestedComponent(root, onCommitUnmount) {
      let node = root;
      while (node) {
          onCommitUnmount(node);
          if (node.child) {
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === root) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === root) {
                  return;
              }
              node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  function commitUpdate(finishedWork) {
      switch (finishedWork.tag) {
          case HostText:
              const text = finishedWork.memoizedProps?.content;
              return commitTextUpdate(finishedWork.stateNode, text);
          case HostComponent:
              return commitPropsUpdate(finishedWork.stateNode, finishedWork.memoizedProps);
          default:
              {
                  console.warn('Unhandled Update');
              }
              break;
      }
  }
  function commitPlacement(finishedWork) {
      {
          console.log('commit Placement');
      }
      const hostParent = getHostParent(finishedWork);
      const sibling = getHostSibling(finishedWork);
      if (hostParent) {
          insertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent, sibling);
      }
  }
  function getHostSibling(fiber) {
      let node = fiber;
      findSibling: while (true) {
          while (node.sibling === null) {
              const parent = node.return;
              if (parent === null ||
                  parent.tag === HostComponent ||
                  parent.tag === HostRoot) {
                  return null;
              }
              node = parent;
          }
          node.sibling.return = node.return;
          node = node.sibling;
          while (node.tag !== HostComponent && node.tag !== HostText) {
              if ((node.flags & MutationMask) !== NoFlags) {
                  continue findSibling;
              }
              if (node.child === null) {
                  continue findSibling;
              }
              node.child.return = node;
              node = node.child;
          }
          if ((node.flags & MutationMask) === NoFlags) {
              return node.stateNode;
          }
      }
  }
  function getHostParent(fiber) {
      let parent = fiber.return;
      while (parent) {
          const parentTag = parent.tag;
          if (parentTag === HostComponent) {
              return parent.stateNode;
          }
          if (parentTag === HostRoot) {
              return parent.stateNode.container;
          }
          parent = parent.return;
      }
      {
          console.warn('No host parent');
      }
      return null;
  }
  function insertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent, before) {
      if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
          if (before) {
              return insertChildToContainer(finishedWork.stateNode, hostParent, before);
          }
          else {
              return appendChildToContainer(hostParent, finishedWork.stateNode);
          }
      }
      const child = finishedWork.child;
      if (child) {
          insertOrAppendPlacementNodeIntoContainer(child, hostParent);
          let sibling = child.sibling;
          while (sibling) {
              insertOrAppendPlacementNodeIntoContainer(sibling, hostParent);
              sibling = sibling.sibling;
          }
      }
  }

  function markUpdate(fiber) {
      fiber.flags |= Update;
  }
  const completeWork = (wip) => {
      const newProps = wip.pendingProps;
      const current = wip.alternate;
      switch (wip.tag) {
          case HostComponent:
              if (current !== null && wip.stateNode) {
                  // update
                  // temmporary solution, need to compare newProps and oldProps, mark update if different
                  markUpdate(wip);
              }
              else {
                  // create DOM and append to parent
                  const instance = createInstance(wip.type, newProps);
                  appendAllChildren(instance, wip);
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return null;
          case HostText:
              if (current !== null && wip.stateNode) {
                  // update
                  const oldText = current.memoizedProps?.content;
                  const newText = newProps.content;
                  if (oldText !== newText) {
                      markUpdate(wip);
                  }
              }
              else {
                  // create DOM and append to parent
                  const instance = createTextInstance(newProps.content);
                  wip.stateNode = instance;
              }
              bubbleProperties(wip);
              return null;
          case HostRoot:
              bubbleProperties(wip);
              break;
          case FunctionComponent:
              bubbleProperties(wip);
              break;
          case Fragment:
              bubbleProperties(wip);
              break;
          default:
              {
                  console.warn('Unknown work tag.');
              }
              break;
      }
  };
  function appendAllChildren(parent, wip) {
      let node = wip.child;
      while (node !== null) {
          if (node?.tag === HostComponent || node?.tag === HostText) {
              appendInitialChild(parent, node?.stateNode);
          }
          else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === wip) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === wip) {
                  return;
              }
              node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  function bubbleProperties(wip) {
      let subtreeFlags = NoFlags;
      let child = wip.child;
      while (child !== null) {
          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;
          child.return = wip;
          child = child.sibling;
      }
      wip.subtreeFlags |= subtreeFlags;
  }

  let syncQueue = null;
  let isFlushingSyncQueue = false;
  function scheduleSyncCallback(callback) {
      if (syncQueue === null) {
          syncQueue = [callback];
      }
      else {
          syncQueue.push(callback);
      }
  }
  function flushSyncCallbacks() {
      if (!isFlushingSyncQueue && syncQueue !== null) {
          isFlushingSyncQueue = true;
          const queue = syncQueue;
          syncQueue = null;
          try {
              for (let i = 0; i < queue.length; i++) {
                  const callback = queue[i];
                  callback();
              }
          }
          catch (error) {
              {
                  console.error('Error in a sync callback', error);
              }
          }
          finally {
              isFlushingSyncQueue = false;
          }
      }
  }

  let workInProgress = null;
  let wipRootRenderLane = NoLane;
  let rootDoesHavePassiveEffects = false;
  function prepareFreshStack(root, lane) {
      workInProgress = createWorkInProgress(root.current, {});
      wipRootRenderLane = lane;
  }
  function scheduleUpdateOnFiber(fiber, lane) {
      const root = markUpdateFromFiberToRoot(fiber);
      markRootUpdated(root, lane);
      ensureRootIsScheduled(root);
  }
  function ensureRootIsScheduled(root) {
      const updateLane = getHighestPriorityLane(root.pendingLanes);
      if (updateLane === NoLane) {
          return;
      }
      if (updateLane === SyncLane) {
          // use microtasks
          {
              console.log('schedule microtask, lane: ', updateLane);
          }
          scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root, updateLane));
          scheduleMicrotask(flushSyncCallbacks);
      }
  }
  function markRootUpdated(root, lane) {
      root.pendingLanes = mergeLanes(root.pendingLanes, lane);
  }
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      let parent = node.return;
      while (parent !== null) {
          node = parent;
          parent = node.return;
      }
      if (node.tag === HostRoot) {
          return node.stateNode;
      }
      return null;
  }
  function performSyncWorkOnRoot(root, lane) {
      const nextLane = getHighestPriorityLane(root.pendingLanes);
      if (nextLane !== SyncLane) {
          ensureRootIsScheduled(root);
          return;
      }
      prepareFreshStack(root, lane);
      do {
          try {
              workLoop();
              break;
          }
          catch (err) {
              {
                  console.warn('workLoop error', err);
              }
              workInProgress = null;
          }
      } while (true);
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork;
      root.finishedLane = lane;
      wipRootRenderLane = NoLane;
      commitRoot(root);
  }
  function commitRoot(root) {
      const finishedWork = root.finishedWork;
      if (finishedWork === null) {
          return;
      }
      {
          console.log('commit phase');
      }
      const lane = root.finishedLane;
      if (lane === NoLane && true) {
          console.error('No lane to commit');
      }
      // reset
      root.finishedWork = null;
      root.finishedLane = NoLane;
      markRootFinished(root, lane);
      if ((finishedWork.flags & PassiveMask) !== NoFlags ||
          (finishedWork.subtreeFlags & PassiveMask) !== NoFlags) {
          if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, () => {
                  flushPassiveEffects(root.pendingPassiveEffects);
                  return;
              });
          }
      }
      // check if there are effects
      const subtreeHasEffect = (finishedWork.subtreeFlags & (MutationMask | PassiveMask)) !== NoFlags;
      const rootHasEffect = (finishedWork.flags & (MutationMask | PassiveMask)) !== NoFlags;
      if (subtreeHasEffect || rootHasEffect) {
          // beforeMutation
          // mutation
          commitMutationEffects(finishedWork, root);
          root.current = finishedWork;
          // layout
      }
      else {
          root.current = finishedWork;
      }
      rootDoesHavePassiveEffects = false;
      ensureRootIsScheduled(root);
  }
  function flushPassiveEffects(pendingPassiveEffects) {
      pendingPassiveEffects.unmount.forEach((effect) => {
          commitHookEffectListUnmount(Passive, effect);
      });
      pendingPassiveEffects.unmount = [];
      pendingPassiveEffects.update.forEach((effect) => {
          commitHookEffectListDestroy(Passive | HookHasEffect, effect);
      });
      pendingPassiveEffects.update.forEach((effect) => {
          commitHookEffectListCreate(Passive | HookHasEffect, effect);
      });
      pendingPassiveEffects.update = [];
      flushSyncCallbacks();
  }
  function workLoop() {
      while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      const next = beginWork(fiber, wipRootRenderLane);
      fiber.memoizedProps = fiber.pendingProps;
      if (next === null) {
          completeUnitOfWork(fiber);
      }
      else {
          workInProgress = next;
      }
  }
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          completeWork(node);
          const sibling = node.sibling;
          if (sibling !== null) {
              workInProgress = sibling;
              return;
          }
          node = node.return;
          workInProgress = node;
      } while (node !== null);
  }

  function createContainer(container) {
      const hostRootFiber = new FiberNode(HostRoot, {}, null);
      const root = new FiberRootNode(container, hostRootFiber);
      hostRootFiber.updateQueue = createUpdateQueue();
      return root;
  }
  function updateContainer(element, root) {
      const hostRootFiber = root.current;
      const lane = requestUpdateLane();
      const update = createUpdate(element, lane);
      enqueueUpdate(hostRootFiber.updateQueue, update);
      scheduleUpdateOnFiber(hostRootFiber, lane);
      return element;
  }

  let idCounter = 0;
  function createRoot() {
      const container = {
          rootId: idCounter++,
          children: [],
      };
      // @ts-ignore
      const root = createContainer(container);
      function getChildren(parent) {
          if (parent) {
              return parent.children;
          }
          return null;
      }
      function getChildrenAsJSX(root) {
          const children = childToJSX(getChildren(root));
          if (Array.isArray(children)) {
              return {
                  $$typeof: REACT_ELEMENT_TYPE,
                  type: REACT_FRAGMENT_TYPE,
                  key: null,
                  ref: null,
                  props: { children },
              };
          }
          return children;
      }
      function childToJSX(child) {
          if (typeof child === 'string' || typeof child === 'number') {
              return child;
          }
          if (Array.isArray(child)) {
              if (child.length === 0) {
                  return null;
              }
              if (child.length === 1) {
                  return childToJSX(child[0]);
              }
              const children = child.map(childToJSX);
              if (children.every((child) => typeof child === 'string' || typeof child === 'number')) {
                  return children.join('');
              }
              return children;
          }
          if (Array.isArray(child.children)) {
              const instance = child;
              const children = childToJSX(instance.children);
              const props = instance.props;
              if (children) {
                  props.children = children;
              }
              return {
                  $$typeof: REACT_ELEMENT_TYPE,
                  type: instance.type,
                  key: null,
                  ref: null,
                  props,
              };
          }
          return child.text;
      }
      return {
          render(element) {
              return updateContainer(element, root);
          },
          getChildren() {
              return getChildren(container);
          },
          getChildrenAsJSX() {
              return getChildrenAsJSX(container);
          },
          _Scheduler: Scheduler__namespace,
      };
  }

  var reactNoopRenderer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return reactNoopRenderer;

}));
